outputPath = 'build'

// If you want to use the Antora integration, set this to true.
// This requires your project to be setup as Antora module.
// You can use `downloadTemplate` task to bootstrap your project.
//useAntoraIntegration = false

// Path where the docToolchain will search for the input files.
// This path is appended to the docDir property specified in gradle.properties
// or in the command line, and therefore must be relative to it.

inputPath = 'docs';

// if you need to register custom Asciidoctor extensions, this is the right place
// configure the name and path to your extension, relative to the root of your project
// (relative to dtcw). For example: 'src/ruby/asciidoctor-lists.rb'.
// this is the same as the `requires`-list of the asciidoctor gradle plugin. The extensions will be
// registered for generateDeck, generateHtml, generatePdf and generateDocbook tasks, only.
// rubyExtensions = []

// the pdfThemeDir config in this file is outdated.
// please check http://doctoolchain.org/docToolchain/v2.0.x/020_tutorial/030_generateHTML.html#_pdf_style for further details
// pdfThemeDir = './src/docs/pdfTheme'

inputFiles = [
	[file: 'index.adoc', formats: ['html']],
	[file: 'dokumentation.adoc', formats: ['pdf']],
]

//folders in which asciidoc will find images.
//these will be copied as resources to ./images
//folders are relative to inputPath
// Hint: If you define an imagepath in your documents like
// :imagesdir: ./whatsoever
// define it conditional like
// ifndef::imagesdir[:imagesdir: ./whatsoever]
// as doctoolchain defines :imagesdir: during generation
imageDirs = ['images/.']

// whether the build should fail when detecting broken image references
// if this config is set to true all images will be embedded
failOnMissingImages = true

// these are directories (dirs) and files which Gradle monitors for a change
// in order to decide if the docs have to be re-build
taskInputsDirs = [
                    "${inputPath}",
                    "${inputPath}/../config"
                 ]

taskInputsFiles = []

//*****************************************************************************************

// Configuration for customTasks
// create a new Task with ./dtcw createTask
customTasks = [
/** customTasks **/
]


//*****************************************************************************************

//Configuration for microsite: generateSite + previewSite

microsite = [:]

// these properties will be set as jBake properties
// microsite.foo will be site.foo in jBake and can be used as config.site_foo in a template
// see https://jbake.org/docs/2.6.4/#configuration for how to configure jBake
// other properties listed here might be used in the jBake templates and thus are not
// documented in the jBake docs but hopefully in the template docs.
microsite.with {
    /** start:microsite **/

    // is your microsite deployed with a context path?
    contextPath = '/'
    // the folder of a site definition (theme) relative to the docDir+inputPath
    //siteFolder = '../site'

    /** end:microsite **/

    //project theme
    //site folder relative to the docs folder
    //see 'copyTheme' for more details
    siteFolder = '../site'

    // the title of the microsite, displayed in the upper left corner
    title = '##site-title##'
    // the next items configure some links in the footer
    //
    // contact eMail
    // example: mailto:bert@example.com
    footerMail = '##footer-email##'
    //
    // twitter account url
    footerTwitter = '##twitter-url##'
    //
    // Stackoverflow QA
    footerSO = '##Stackoverflow-url##'
    //
    // Github Repository
    footerGithub = '##Github-url##'
    //
    // Slack Channel
    footerSlack = '##Slack-url##'
    //
    // Footer Text
    // example: <small class="text-white">built with docToolchain and jBake <br /> theme: docsy</small>
    footerText = '<small class="text-white">built with <a href="https://doctoolchain.org">docToolchain</a> and <a href="https://jbake.org">jBake</a> <br /> theme: <a href="https://www.docsy.dev/">docsy</a></small>'
    //
    // site title if no other title is given
    title = 'docToolchain'
    //
    // the url to create an issue in github
    // Example: https://github.com/docToolchain/docToolchain/issues/new
    issueUrl = '##issue-url##'
    //
    // the base url for code files in github
    // Example: https://github.com/doctoolchain/doctoolchain/edit/master/src/docs
    branch = System.getenv("DTC_PROJECT_BRANCH")?:'-'
    gitRepoUrl = '##git-repo-url##'

    //
    // the location of the landing page
    landingPage = 'landingpage.gsp'
    // the menu of the microsite. A map of [code:'title'] entries to specify the order and title of the entries.
    // the codes are autogenerated from the folder names or :jbake-menu: attribute entries from the .adoc file headers
    // set a title to '-' in order to remove this menu entry.
    menu = [:]

//tag::additionalConverters[]
/**

if you need support for additional markup converters, you can configure them here
you have three different types of script you can define:

- groovy: just groovy code as string
- groovyFile: path to a groovy script
- bash: a bash command. It will receive the name of the file to be converted as first argument

`groovy` and `groovyFile` will have access to the file and config object

`dtcw:rstToHtml.py` is an internal script to convert restructuredText.
Needs `python3` and `docutils` installed.

**/
    additionalConverters = [
        //'.one': [command: 'println "test"+file.canonicalPath', type: 'groovy'],
        //'.two': [command: 'scripts/convert-md.groovy', type: 'groovyFile'],
        //'.rst': [command: 'dtcw:rstToHtml.py', type: 'bash'],
    ]
//end::additionalConverters[]

    // if you prefer another convention regarding the automatic generation
    // of jBake headers, you can configure a script to modify them here
    // the script has access to
    // - file: the current object
    // - sourceFolder: the copy of the docs-source on which the build operates
    //                 default `/microsite/tmp/site/doc`
    // - config: the config object (this file, but parsed)
    // - headers: already parsed headers to be modified
    /**
    customConvention = """
        System.out.println file.canonicalPath
        headers.title += " - from CustomConvention"
    """.stripIndent()
    **/
}

//*****************************************************************************************

//Configuration for exportChangelog

exportChangelog = [:]

changelog.with {

    // Directory of which the exportChangelog task will export the changelog.
    // It should be relative to the docDir directory provided in the
    // gradle.properties file.
    dir = 'src/docs'

    // Command used to fetch the list of changes.
    // It should be a single command taking a directory as a parameter.
    // You cannot use multiple commands with pipe between.
    // This command will be executed in the directory specified by changelogDir
    // it the environment inherited from the parent process.
    // This command should produce asciidoc text directly. The exportChangelog
    // task does not do any post-processing
    // of the output of that command.
    //
    // See also https://git-scm.com/docs/pretty-formats
    cmd = 'git log --pretty=format:%x7c%x20%ad%x20%n%x7c%x20%an%x20%n%x7c%x20%s%x20%n --date=short'

}

//*****************************************************************************************

//tag::htmlSanityCheckConfig[]
htmlSanityCheck.with {
    //sourceDir = "build/html5/site"
    //checkingResultsDir =
}
//end::htmlSanityCheckConfig[]



//tag::openApiConfig[]
// Configuration for OpenAPI related task
openApi = [:]

// 'specFile' is the name of OpenAPI specification yaml file. Tool expects this file inside working dir (as a filename or relative path with filename)
// 'infoUrl' and 'infoEmail' are specification metadata about further info related to the API. By default this values would be filled by openapi-generator plugin placeholders
//

openApi.with {
    specFile = 'src/docs/petstore-v2.0.yaml' // i.e. 'petstore.yaml', 'src/doc/petstore.yaml'
    infoUrl = 'https://my-api.company.com'
    infoEmail = 'info@company.com'
}
//end::openApiConfig[]

//tag::collectIncludesConfig[]
collectIncludes = [:]

collectIncludes.with {

    fileFilter = "adoc" // define which files are considered. default: "ad|adoc|asciidoc"

    minPrefixLength = "3" // define what minimum length the prefix. default: "3"

    maxPrefixLength = "3" // define what maximum length the prefix. default: ""

    separatorChar = "_" // define the allowed separators after prefix. default: "-_"

    cleanOutputFolder = true // should the output folder be emptied before generation? default: false

    excludeDirectories = [] // define additional directories that should not be traversed.

}
//end::collectIncludesConfig[]


//tag::openAIConfig[]
// Configuration for openAI related tasks
openAI = [:]

openAI.with {
    // This task requires a person access token for openAI.
    // Ensure to pass this token as parameters when calling the task
    // using -PopenAI.token=xx-xxxxxxxxxxxxxx

    //model = "text-davinci-003"
    //maxToken = '500'
    //temperature = '0.3'
}
//end::openAIConfig[]
